"""
Calendar Handler - X·ª≠ l√Ω t·∫°o l·ªãch h·ªçc/l·ªãch c√° nh√¢n
T√≠ch h·ª£p v·ªõi file processing v√† t·∫°o Google Calendar import code
"""

import sys
import os
import csv
import json
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional
from dataclasses import dataclass, asdict
import tempfile

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from src.utils.basetools.file_reading_tool import read_file_tool
# from src.utils.basetools.document_chunking_tool import chunk_document
from src.data.cache.memory_handler import MessageMemoryHandler
from config.system_config import config

@dataclass
class TimeSlot:
    day_of_week: str  # "Monday", "Tuesday", etc.
    start_time: str   # "08:00"
    end_time: str     # "10:00"
    duration_minutes: int

@dataclass
class CalendarEvent:
    title: str
    description: str
    start_datetime: datetime
    end_datetime: datetime
    location: str
    category: str  # "study", "exercise", "meeting", "personal"
    recurrence: Optional[str]  # "weekly", "daily", None

@dataclass
class CalendarSummary:
    total_events: int
    study_hours_per_week: int
    free_time_slots: List[TimeSlot]
    conflicts: List[str]
    recommendations: List[str]

@dataclass
class CalendarResponse:
    calendar_summary: CalendarSummary
    events: List[CalendarEvent]
    csv_file_path: str
    google_calendar_code: str
    user_approved: bool = False

class CalendarHandler:
    """
    X·ª≠ l√Ω vi·ªác t·∫°o l·ªãch h·ªçc t·∫≠p v√† c√° nh√¢n
    """
    
    def __init__(self):
        self.memory_handler = MessageMemoryHandler()
        self.temp_storage = {}  # Temporary storage for conversation data
        
        # Template l·ªãch h·ªçc chu·∫©n t·ª´ config
        calendar_template = config.get_calendar_template()
        self.standard_schedule_templates = {
            "university_semester": {
                "periods_per_day": 6,
                "period_duration": calendar_template["period_duration"],  # minutes
                "break_duration": 15,   # minutes
                "start_time": calendar_template["start_time"],
                "working_days": calendar_template["work_days"]
            },
            "high_school": {
                "periods_per_day": 8,
                "period_duration": 45,
                "break_duration": 10,
                "start_time": "07:00", 
                "working_days": ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
            }
        }
    
    def handle_calendar_request(self, user_input: str, session_id: str) -> Dict[str, Any]:
        """
        X·ª≠ l√Ω y√™u c·∫ßu t·∫°o l·ªãch t·ª´ user
        """
        # 1. Ph√¢n t√≠ch intent v√† thu th·∫≠p th√¥ng tin c·∫ßn thi·∫øt
        required_info = self._analyze_calendar_requirements(user_input)
        
        # 2. Ki·ªÉm tra th√¥ng tin c√≤n thi·∫øu
        missing_info = self._check_missing_information(required_info, session_id)
        
        if missing_info:
            return {
                "type": "request_more_info",
                "message": self._create_info_request_message(missing_info),
                "missing_fields": missing_info
            }
        
        # 3. X·ª≠ l√Ω file th·ªùi kh√≥a bi·ªÉu n·∫øu c√≥
        schedule_data = self._process_schedule_files(session_id)
        
        # 4. T·∫°o l·ªãch d·ª±a tr√™n th√¥ng tin ƒë√£ thu th·∫≠p
        calendar_response = self._generate_calendar(required_info, schedule_data, session_id)
        
        # 5. T·∫°o file CSV v√† code Google Calendar
        csv_path = self._create_csv_file(calendar_response.events)
        google_code = self._generate_google_calendar_code(calendar_response.events)
        
        calendar_response.csv_file_path = csv_path
        calendar_response.google_calendar_code = google_code
        
        return {
            "type": "calendar_preview",
            "calendar_response": calendar_response,
            "preview_message": self._create_calendar_preview_message(calendar_response)
        }
    
    def _analyze_calendar_requirements(self, user_input: str) -> Dict[str, Any]:
        """
        Ph√¢n t√≠ch y√™u c·∫ßu c·ªßa user ƒë·ªÉ x√°c ƒë·ªãnh th√¥ng tin c·∫ßn thi·∫øt
        """
        user_input_lower = user_input.lower()
        
        requirements = {
            "calendar_type": "personal",  # "study", "exercise", "personal", "mixed"
            "duration_weeks": 4,  # Default 4 weeks
            "priorities": [],
            "constraints": [],
            "schedule_type": "university_semester"  # Default
        }
        
        # X√°c ƒë·ªãnh lo·∫°i l·ªãch
        if any(word in user_input_lower for word in ["h·ªçc", "m√¥n h·ªçc", "kh√≥a h·ªçc", "study"]):
            requirements["calendar_type"] = "study"
        elif any(word in user_input_lower for word in ["t·∫≠p", "th·ªÉ d·ª•c", "gym", "exercise"]):
            requirements["calendar_type"] = "exercise"
        elif any(word in user_input_lower for word in ["c√° nh√¢n", "sinh ho·∫°t", "personal"]):
            requirements["calendar_type"] = "personal"
        else:
            requirements["calendar_type"] = "mixed"
        
        # X√°c ƒë·ªãnh th·ªùi gian
        if "tu·∫ßn" in user_input_lower:
            # T√¨m s·ªë tu·∫ßn
            words = user_input.split()
            for i, word in enumerate(words):
                if "tu·∫ßn" in word and i > 0:
                    try:
                        requirements["duration_weeks"] = int(words[i-1])
                    except ValueError:
                        pass
        
        # X√°c ƒë·ªãnh priorities t·ª´ t·ª´ kh√≥a
        priority_keywords = {
            "to√°n": "Mathematics",
            "l√Ω": "Physics", 
            "h√≥a": "Chemistry",
            "anh": "English",
            "vƒÉn": "Literature",
            "th·ªÉ d·ª•c": "Physical Education",
            "tin h·ªçc": "Computer Science"
        }
        
        for keyword, subject in priority_keywords.items():
            if keyword in user_input_lower:
                requirements["priorities"].append(subject)
        
        return requirements
    
    def _check_missing_information(self, requirements: Dict[str, Any], session_id: str) -> List[str]:
        """
        Ki·ªÉm tra th√¥ng tin c√≤n thi·∫øu c·∫ßn h·ªèi th√™m user
        """
        missing = []
        
        # L·∫•y th√¥ng tin ƒë√£ c√≥ t·ª´ conversation
        stored_info = self.temp_storage.get(session_id, {})
        
        # C√°c th√¥ng tin c·∫ßn thi·∫øt
        required_fields = {
            "schedule_file": "File th·ªùi kh√≥a bi·ªÉu hi·ªán t·∫°i",
            "preferred_study_times": "Th·ªùi gian h·ªçc ∆∞a th√≠ch", 
            "break_preferences": "Th·ªùi gian ngh·ªâ mong mu·ªën",
            "special_requirements": "Y√™u c·∫ßu ƒë·∫∑c bi·ªát"
        }
        
        for field, description in required_fields.items():
            if field not in stored_info and field not in requirements:
                missing.append(field)
        
        return missing
    
    def _create_info_request_message(self, missing_info: List[str]) -> str:
        """
        T·∫°o message y√™u c·∫ßu th√¥ng tin t·ª´ user
        """
        messages = []
        
        messages.append("üìÖ **ƒê·ªÇ T·∫†O L·ªäCH T·ªêI ∆ØU, T√îI C·∫¶N TH√äM TH√îNG TIN:**")
        messages.append("")
        
        if "schedule_file" in missing_info:
            messages.append("üìé **1. File th·ªùi kh√≥a bi·ªÉu hi·ªán t·∫°i**")
            messages.append("   - Vui l√≤ng upload file th·ªùi kh√≥a bi·ªÉu (Excel, PDF, txt)")
            messages.append("   - Ho·∫∑c g√µ tr·ª±c ti·∫øp l·ªãch h·ªçc hi·ªán t·∫°i c·ªßa b·∫°n")
            messages.append("")
        
        if "preferred_study_times" in missing_info:
            messages.append("‚è∞ **2. Th·ªùi gian h·ªçc ∆∞a th√≠ch**")
            messages.append("   - B·∫°n th√≠ch h·ªçc v√†o khung gi·ªù n√†o? (VD: s√°ng 7-11h, chi·ªÅu 14-17h)")
            messages.append("   - C√≥ m√¥n n√†o b·∫°n mu·ªën ∆∞u ti√™n kh√¥ng?")
            messages.append("")
        
        if "break_preferences" in missing_info:
            messages.append("‚òï **3. Th·ªùi gian ngh·ªâ**")
            messages.append("   - B·∫°n mu·ªën ngh·ªâ bao l√¢u gi·ªØa c√°c bu·ªïi h·ªçc? (15p, 30p, 1h)")
            messages.append("   - C√≥ ho·∫°t ƒë·ªông g√¨ trong gi·ªù ngh·ªâ kh√¥ng?")
            messages.append("")
        
        if "special_requirements" in missing_info:
            messages.append("‚ö° **4. Y√™u c·∫ßu ƒë·∫∑c bi·ªát**")
            messages.append("   - C√≥ r√†ng bu·ªôc v·ªÅ th·ªùi gian kh√¥ng? (VD: kh√¥ng h·ªçc t·ªëi mu·ªôn)")
            messages.append("   - C√≥ ho·∫°t ƒë·ªông c·ªë ƒë·ªãnh n√†o c·∫ßn tr√°nh kh√¥ng?")
            messages.append("")
        
        messages.append("üí° **H√£y cung c·∫•p t·ª´ng th√¥ng tin, t√¥i s·∫Ω ghi nh·∫≠n v√† x·ª≠ l√Ω!**")
        
        return "\n".join(messages)
    
    def store_user_info(self, session_id: str, info_type: str, info_content: str) -> str:
        """
        L∆∞u th√¥ng tin user cung c·∫•p v√†o temporary storage
        """
        if session_id not in self.temp_storage:
            self.temp_storage[session_id] = {}
        
        self.temp_storage[session_id][info_type] = info_content
        
        return f"‚úÖ ƒê√£ ghi nh·∫≠n th√¥ng tin v·ªÅ {info_type}. C·∫£m ∆°n b·∫°n!"
    
    def _process_schedule_files(self, session_id: str) -> Dict[str, Any]:
        """
        X·ª≠ l√Ω file th·ªùi kh√≥a bi·ªÉu m√† user upload
        """
        stored_info = self.temp_storage.get(session_id, {})
        schedule_data = {"events": [], "constraints": []}
        
        if "schedule_file" in stored_info:
            try:
                # Gi·∫£ s·ª≠ user ƒë√£ upload file v√† path ƒë∆∞·ª£c l∆∞u
                file_path = stored_info["schedule_file"]
                
                # ƒê·ªçc file (simplified without FileReadInput)
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read()
                
                # Chunk v√† ph√¢n t√≠ch content (simplified without chunk_document)
                content_chunks = [file_content[:2000]]  # Simple chunking
                schedule_data = self._parse_schedule_from_content(content_chunks)
                
            except Exception as e:
                print(f"Error processing schedule file: {e}")
                schedule_data = {"events": [], "constraints": [], "error": str(e)}
        
        return schedule_data
    
    def _parse_schedule_from_content(self, content_chunks: List[str]) -> Dict[str, Any]:
        """
        Parse l·ªãch h·ªçc t·ª´ content chunks
        """
        events = []
        constraints = []
        
        # ƒê∆°n gi·∫£n h√≥a parsing logic
        for chunk in content_chunks:
            chunk_lower = chunk.lower()
            
            # T√¨m th·ªùi gian v√† m√¥n h·ªçc
            if any(day in chunk_lower for day in ["th·ª©", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]):
                # Extract event info
                lines = chunk.split('\n')
                for line in lines:
                    if any(time_indicator in line for time_indicator in [":", "h", "gi·ªù"]):
                        # T·∫°o event t·ª´ line n√†y
                        event_info = self._extract_event_from_line(line)
                        if event_info:
                            events.append(event_info)
        
        return {"events": events, "constraints": constraints}
    
    def _extract_event_from_line(self, line: str) -> Optional[Dict[str, Any]]:
        """
        Extract th√¥ng tin event t·ª´ m·ªôt d√≤ng text
        """
        # ƒê∆°n gi·∫£n h√≥a - return placeholder
        # TODO: Implement proper parsing logic
        return {
            "title": "M√¥n h·ªçc",
            "time": "08:00-10:00",
            "day": "Monday",
            "location": "Ph√≤ng h·ªçc"
        }
    
    def _generate_calendar(self, requirements: Dict[str, Any], schedule_data: Dict[str, Any], session_id: str) -> CalendarResponse:
        """
        T·∫°o l·ªãch d·ª±a tr√™n requirements v√† schedule data
        """
        events = []
        
        # L·∫•y template
        template = self.standard_schedule_templates[requirements["schedule_type"]]
        
        # T·∫°o events cho s·ªë tu·∫ßn ƒë∆∞·ª£c y√™u c·∫ßu
        start_date = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        
        for week in range(requirements["duration_weeks"]):
            week_start = start_date + timedelta(weeks=week)
            
            for day_offset, day_name in enumerate(template["working_days"]):
                current_date = week_start + timedelta(days=day_offset)
                
                # T·∫°o events cho ng√†y n√†y
                daily_events = self._generate_daily_events(
                    current_date, 
                    requirements, 
                    template,
                    schedule_data
                )
                events.extend(daily_events)
        
        # T·∫°o summary
        calendar_summary = self._create_calendar_summary(events, requirements)
        
        return CalendarResponse(
            calendar_summary=calendar_summary,
            events=events,
            csv_file_path="",  # S·∫Ω ƒë∆∞·ª£c set sau
            google_calendar_code=""  # S·∫Ω ƒë∆∞·ª£c set sau
        )
    
    def _generate_daily_events(self, date: datetime, requirements: Dict[str, Any], template: Dict[str, Any], schedule_data: Dict[str, Any]) -> List[CalendarEvent]:
        """
        T·∫°o events cho m·ªôt ng√†y c·ª• th·ªÉ
        """
        events = []
        
        # Parse start time
        start_hour, start_minute = map(int, template["start_time"].split(":"))
        current_time = date.replace(hour=start_hour, minute=start_minute)
        
        # T·∫°o c√°c periods trong ng√†y
        for period in range(template["periods_per_day"]):
            # T√≠nh th·ªùi gian c·ªßa period
            period_start = current_time + timedelta(minutes=period * (template["period_duration"] + template["break_duration"]))
            period_end = period_start + timedelta(minutes=template["period_duration"])
            
            # T·∫°o event (simplified)
            if requirements["calendar_type"] == "study":
                event_title = f"H·ªçc t·∫≠p - Ti·∫øt {period + 1}"
                event_category = "study"
            elif requirements["calendar_type"] == "exercise":
                event_title = f"Luy·ªán t·∫≠p - Bu·ªïi {period + 1}"
                event_category = "exercise"
            else:
                event_title = f"Ho·∫°t ƒë·ªông {period + 1}"
                event_category = "personal"
            
            event = CalendarEvent(
                title=event_title,
                description=f"Ho·∫°t ƒë·ªông ƒë∆∞·ª£c l√™n l·ªãch t·ª± ƒë·ªông",
                start_datetime=period_start,
                end_datetime=period_end,
                location="",
                category=event_category,
                recurrence=None
            )
            
            events.append(event)
        
        return events
    
    def _create_calendar_summary(self, events: List[CalendarEvent], requirements: Dict[str, Any]) -> CalendarSummary:
        """
        T·∫°o summary cho calendar
        """
        total_events = len(events)
        
        # T√≠nh study hours per week
        study_events = [e for e in events if e.category == "study"]
        total_study_minutes = sum((e.end_datetime - e.start_datetime).total_seconds() / 60 for e in study_events)
        study_hours_per_week = int(total_study_minutes / 60 / requirements["duration_weeks"])
        
        # T√¨m free time slots (simplified)
        free_slots = [
            TimeSlot("Saturday", "19:00", "22:00", 180),
            TimeSlot("Sunday", "08:00", "18:00", 600)
        ]
        
        # T√¨m conflicts (simplified)
        conflicts = []
        
        # T·∫°o recommendations
        recommendations = [
            "N√™n ngh·ªâ 15 ph√∫t gi·ªØa c√°c bu·ªïi h·ªçc",
            "∆Øu ti√™n h·ªçc c√°c m√¥n kh√≥ v√†o bu·ªïi s√°ng",
            "D√†nh th·ªùi gian √¥n t·∫≠p v√†o cu·ªëi tu·∫ßn"
        ]
        
        return CalendarSummary(
            total_events=total_events,
            study_hours_per_week=study_hours_per_week,
            free_time_slots=free_slots,
            conflicts=conflicts,
            recommendations=recommendations
        )
    
    def _create_csv_file(self, events: List[CalendarEvent]) -> str:
        """
        T·∫°o file CSV t·ª´ events
        """
        try:
            # T·∫°o temporary file
            temp_file = tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False, encoding='utf-8')
            
            # Write CSV header
            fieldnames = ['Subject', 'Start Date', 'Start Time', 'End Date', 'End Time', 'Description', 'Location', 'Category']
            writer = csv.DictWriter(temp_file, fieldnames=fieldnames)
            writer.writeheader()
            
            # Write events
            for event in events:
                writer.writerow({
                    'Subject': event.title,
                    'Start Date': event.start_datetime.strftime('%m/%d/%Y'),
                    'Start Time': event.start_datetime.strftime('%H:%M'),
                    'End Date': event.end_datetime.strftime('%m/%d/%Y'),
                    'End Time': event.end_datetime.strftime('%H:%M'),
                    'Description': event.description,
                    'Location': event.location,
                    'Category': event.category
                })
            
            temp_file.close()
            return temp_file.name
            
        except Exception as e:
            print(f"Error creating CSV file: {e}")
            return ""
    
    def _generate_google_calendar_code(self, events: List[CalendarEvent]) -> str:
        """
        T·∫°o code Python ƒë·ªÉ import v√†o Google Calendar
        """
        code_template = '''"""
Google Calendar Import Script
T·ª± ƒë·ªông t·∫°o t·ª´ h·ªá th·ªëng Calendar Handler
"""

from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.discovery import build
import pickle
import os
from datetime import datetime

# Scopes needed for Google Calendar
SCOPES = ['https://www.googleapis.com/auth/calendar']

def authenticate_google_calendar():
    """Authenticate with Google Calendar API"""
    creds = None
    
    # Token file stores the user's access and refresh tokens
    if os.path.exists('token.pickle'):
        with open('token.pickle', 'rb') as token:
            creds = pickle.load(token)
    
    # If there are no (valid) credentials available, let the user log in
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                'credentials.json', SCOPES)
            creds = flow.run_local_server(port=0)
        
        # Save the credentials for the next run
        with open('token.pickle', 'wb') as token:
            pickle.dump(creds, token)
    
    return build('calendar', 'v3', credentials=creds)

def create_calendar_events():
    """Create calendar events"""
    service = authenticate_google_calendar()
    
    events_data = [
'''
        
        # Add events data
        for event in events:
            event_dict = {
                'summary': event.title,
                'description': event.description,
                'location': event.location,
                'start': {
                    'dateTime': event.start_datetime.isoformat(),
                    'timeZone': 'Asia/Ho_Chi_Minh'
                },
                'end': {
                    'dateTime': event.end_datetime.isoformat(),
                    'timeZone': 'Asia/Ho_Chi_Minh'
                }
            }
            code_template += f"        {event_dict},\n"
        
        code_template += '''    ]
    
    # Create events
    for event_data in events_data:
        try:
            event = service.events().insert(calendarId='primary', body=event_data).execute()
            print(f"Event created: {event['summary']}")
        except Exception as e:
            print(f"Error creating event {event_data['summary']}: {e}")

if __name__ == "__main__":
    print("ƒêang t·∫°o events trong Google Calendar...")
    create_calendar_events()
    print("Ho√†n th√†nh!")
'''
        
        return code_template
    
    def _create_calendar_preview_message(self, calendar_response: CalendarResponse) -> str:
        """
        T·∫°o preview message cho calendar
        """
        summary = calendar_response.calendar_summary
        
        preview_parts = []
        
        preview_parts.append("üìÖ **T√ìM T·∫ÆT L·ªäCH TR√åNH ƒê√É T·∫†O**")
        preview_parts.append("")
        preview_parts.append(f"üìä **Th·ªëng k√™:**")
        preview_parts.append(f"   ‚Ä¢ T·ªïng s·ªë s·ª± ki·ªán: {summary.total_events}")
        preview_parts.append(f"   ‚Ä¢ Gi·ªù h·ªçc/tu·∫ßn: {summary.study_hours_per_week} ti·∫øng")
        preview_parts.append("")
        
        if summary.free_time_slots:
            preview_parts.append("üïê **Th·ªùi gian r·∫£nh:**")
            for slot in summary.free_time_slots:
                preview_parts.append(f"   ‚Ä¢ {slot.day_of_week}: {slot.start_time} - {slot.end_time}")
            preview_parts.append("")
        
        if summary.conflicts:
            preview_parts.append("‚ö†Ô∏è **Xung ƒë·ªôt l·ªãch:**")
            for conflict in summary.conflicts:
                preview_parts.append(f"   ‚Ä¢ {conflict}")
            preview_parts.append("")
        
        if summary.recommendations:
            preview_parts.append("üí° **G·ª£i √Ω:**")
            for rec in summary.recommendations:
                preview_parts.append(f"   ‚Ä¢ {rec}")
            preview_parts.append("")
        
        preview_parts.append("üìé **File ƒë√£ t·∫°o:**")
        preview_parts.append(f"   ‚Ä¢ File CSV: {calendar_response.csv_file_path}")
        preview_parts.append("   ‚Ä¢ Code Google Calendar: ƒê√£ t·∫°o")
        preview_parts.append("")
        
        preview_parts.append("‚ùì **B·∫°n c√≥ h√†i l√≤ng v·ªõi l·ªãch n√†y kh√¥ng?**")
        preview_parts.append("   ‚Ä¢ Tr·∫£ l·ªùi 'OK' n·∫øu ƒë·ªìng √Ω")
        preview_parts.append("   ‚Ä¢ Tr·∫£ l·ªùi 'S·ª¨A' ƒë·ªÉ ch·ªânh s·ª≠a")
        preview_parts.append("   ‚Ä¢ Tr·∫£ l·ªùi 'GOOGLE' ƒë·ªÉ nh·∫≠n code import Google Calendar")
        
        return "\n".join(preview_parts)
    
    def approve_calendar(self, session_id: str) -> Dict[str, Any]:
        """
        User approve calendar v√† cung c·∫•p final files
        """
        return {
            "message": "‚úÖ L·ªãch tr√¨nh ƒë√£ ƒë∆∞·ª£c ph√™ duy·ªát! File CSV v√† code ƒë√£ s·∫µn s√†ng.",
            "files_ready": True
        }
    
    def get_google_calendar_instructions(self) -> str:
        """
        Tr·∫£ v·ªÅ h∆∞·ªõng d·∫´n setup Google Calendar
        """
        instructions = '''
üîß **H∆Ø·ªöNG D·∫™N SETUP GOOGLE CALENDAR API**

**B∆∞·ªõc 1: T·∫°o Google Cloud Project**
1. Truy c·∫≠p: https://console.cloud.google.com/
2. T·∫°o project m·ªõi ho·∫∑c ch·ªçn project hi·ªán c√≥
3. Enable Google Calendar API

**B∆∞·ªõc 2: T·∫°o Credentials**
1. V√†o "APIs & Services" > "Credentials"
2. Click "Create Credentials" > "OAuth 2.0 Client IDs"
3. Ch·ªçn "Desktop Application"
4. Download file JSON v√† ƒë·ªïi t√™n th√†nh "credentials.json"

**B∆∞·ªõc 3: C√†i ƒë·∫∑t th∆∞ vi·ªán**
```bash
pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client
```

**B∆∞·ªõc 4: Ch·∫°y code**
1. ƒê·∫∑t file "credentials.json" c√πng th∆∞ m·ª•c v·ªõi code
2. Ch·∫°y script Python ƒë√£ t·∫°o
3. Authorize l·∫ßn ƒë·∫ßu qua browser

**L∆∞u √Ω:** 
- Token s·∫Ω ƒë∆∞·ª£c l∆∞u ƒë·ªÉ s·ª≠ d·ª•ng l·∫ßn sau
- Code s·∫Ω t·ª± ƒë·ªông t·∫°o t·∫•t c·∫£ events trong calendar
        '''
        
        return instructions
